<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: ankerl::nanobench::Rng Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classankerl_1_1nanobench_1_1Rng.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classankerl_1_1nanobench_1_1Rng-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ankerl::nanobench::Rng Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="nanobench_8h_source.html">nanobench.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad016f155c687ea1720a75345421b02e7" id="r_ad016f155c687ea1720a75345421b02e7"><td class="memItemLeft" align="right" valign="top"><a id="ad016f155c687ea1720a75345421b02e7" name="ad016f155c687ea1720a75345421b02e7"></a>
<a class="el" href="classWriter.html">using</a>&#160;</td><td class="memItemRight" valign="bottom"><b>result_type</b> = uint64_t</td></tr>
<tr class="memdesc:ad016f155c687ea1720a75345421b02e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This RNG provides 64bit randomness. <br /></td></tr>
<tr class="separator:ad016f155c687ea1720a75345421b02e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b113050f04adf292a2f32a5463b9105" id="r_a4b113050f04adf292a2f32a5463b9105"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html#a4b113050f04adf292a2f32a5463b9105">Rng</a> (<a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> const &amp;)=<a class="el" href="classWriter.html">delete</a></td></tr>
<tr class="separator:a4b113050f04adf292a2f32a5463b9105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ced30ccef127468deea63617c9d4fd" id="r_aa1ced30ccef127468deea63617c9d4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html#aa1ced30ccef127468deea63617c9d4fd">operator=</a> (<a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> const &amp;)=<a class="el" href="classWriter.html">delete</a></td></tr>
<tr class="separator:aa1ced30ccef127468deea63617c9d4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bea525c8574ae7f79e78e27e91b47b9" id="r_a6bea525c8574ae7f79e78e27e91b47b9"><td class="memItemLeft" align="right" valign="top"><a id="a6bea525c8574ae7f79e78e27e91b47b9" name="a6bea525c8574ae7f79e78e27e91b47b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Rng</b> (<a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> &amp;&amp;) noexcept=<a class="el" href="classWriter.html">default</a></td></tr>
<tr class="separator:a6bea525c8574ae7f79e78e27e91b47b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2fd965224459bd2bed25ec75642bfd" id="r_a6c2fd965224459bd2bed25ec75642bfd"><td class="memItemLeft" align="right" valign="top"><a id="a6c2fd965224459bd2bed25ec75642bfd" name="a6c2fd965224459bd2bed25ec75642bfd"></a>
<a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> &amp;&amp;) noexcept=<a class="el" href="classWriter.html">default</a></td></tr>
<tr class="separator:a6c2fd965224459bd2bed25ec75642bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765caca3a2c4896c54aa0419f4680b39" id="r_a765caca3a2c4896c54aa0419f4680b39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html#a765caca3a2c4896c54aa0419f4680b39">Rng</a> ()</td></tr>
<tr class="memdesc:a765caca3a2c4896c54aa0419f4680b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new Random generator with random seed.  <br /></td></tr>
<tr class="separator:a765caca3a2c4896c54aa0419f4680b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f806b6c152353221767435ae74fc282" id="r_a2f806b6c152353221767435ae74fc282"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html#a2f806b6c152353221767435ae74fc282">Rng</a> (uint64_t <a class="el" href="classWriter.html">seed</a>) noexcept</td></tr>
<tr class="separator:a2f806b6c152353221767435ae74fc282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec75d051792f383f66917baa4d21e26" id="r_a4ec75d051792f383f66917baa4d21e26"><td class="memItemLeft" align="right" valign="top"><a id="a4ec75d051792f383f66917baa4d21e26" name="a4ec75d051792f383f66917baa4d21e26"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Rng</b> (uint64_t x, uint64_t y) noexcept</td></tr>
<tr class="separator:a4ec75d051792f383f66917baa4d21e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7c94b28c41877160603489301f1071" id="r_abb7c94b28c41877160603489301f1071"><td class="memItemLeft" align="right" valign="top"><a id="abb7c94b28c41877160603489301f1071" name="abb7c94b28c41877160603489301f1071"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Rng</b> (std::vector&lt; uint64_t &gt; const &amp;data)</td></tr>
<tr class="separator:abb7c94b28c41877160603489301f1071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c9c7bd41ec8944f542e512ea7d6038" id="r_a08c9c7bd41ec8944f542e512ea7d6038"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html#a08c9c7bd41ec8944f542e512ea7d6038">ANKERL_NANOBENCH</a> (<a class="el" href="classWriter.html">NODISCARD</a>) <a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> <a class="el" href="classWriter.html">copy</a>() const noexcept</td></tr>
<tr class="separator:a08c9c7bd41ec8944f542e512ea7d6038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7b5e0d8b201e7367dc44b40910b81c" id="r_a2c7b5e0d8b201e7367dc44b40910b81c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html#a2c7b5e0d8b201e7367dc44b40910b81c">operator()</a> () noexcept</td></tr>
<tr class="memdesc:a2c7b5e0d8b201e7367dc44b40910b81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produces a 64bit random value. This should be very fast, thus it is marked as inline. In my benchmark, this is ~46 times faster than <code>std::default_random_engine</code> for producing 64bit random values. It seems that the fastest std contender is <code>std::mt19937_64</code>. Still, this RNG is 2-3 times as fast.  <br /></td></tr>
<tr class="separator:a2c7b5e0d8b201e7367dc44b40910b81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3219bbffe1d0f487e69a0bc9c0f00e" id="r_afb3219bbffe1d0f487e69a0bc9c0f00e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html#afb3219bbffe1d0f487e69a0bc9c0f00e">bounded</a> (uint32_t range) noexcept</td></tr>
<tr class="separator:afb3219bbffe1d0f487e69a0bc9c0f00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70a7784c044c9870682eb22094049fb" id="r_ac70a7784c044c9870682eb22094049fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classWriter.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html#ac70a7784c044c9870682eb22094049fb">uniform01</a> () noexcept</td></tr>
<tr class="separator:ac70a7784c044c9870682eb22094049fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5314a16ff500c254f8431cc3a03578f9" id="r_a5314a16ff500c254f8431cc3a03578f9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classWriter.html">typename</a> <a class="el" href="classWriter.html">Container</a> &gt; </td></tr>
<tr class="memitem:a5314a16ff500c254f8431cc3a03578f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classWriter.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html#a5314a16ff500c254f8431cc3a03578f9">shuffle</a> (<a class="el" href="classWriter.html">Container</a> &amp;<a class="el" href="classWriter.html">container</a>) noexcept</td></tr>
<tr class="separator:a5314a16ff500c254f8431cc3a03578f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a47adce9a189d828f1054b87602354ad0" id="r_a47adce9a189d828f1054b87602354ad0"><td class="memItemLeft" align="right" valign="top"><a id="a47adce9a189d828f1054b87602354ad0" name="a47adce9a189d828f1054b87602354ad0"></a>
<a class="el" href="classWriter.html">static</a> <a class="el" href="classWriter.html">constexpr</a> uint64_t()&#160;</td><td class="memItemRight" valign="bottom"><b>min</b> ()</td></tr>
<tr class="separator:a47adce9a189d828f1054b87602354ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac038649162b516549cf98b743d04e2cb" id="r_ac038649162b516549cf98b743d04e2cb"><td class="memItemLeft" align="right" valign="top"><a id="ac038649162b516549cf98b743d04e2cb" name="ac038649162b516549cf98b743d04e2cb"></a>
<a class="el" href="classWriter.html">static</a> <a class="el" href="classWriter.html">constexpr</a> uint64_t()&#160;</td><td class="memItemRight" valign="bottom"><b>max</b> ()</td></tr>
<tr class="separator:ac038649162b516549cf98b743d04e2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An extremely fast random generator. Currently, this implements <em>RomuDuoJr</em>, developed by Mark Overton. Source: <a href="http://www.romu-random.org/">http://www.romu-random.org/</a></p>
<p>RomuDuoJr is extremely fast and provides reasonable good randomness. Not enough for large jobs, but definitely good enough for a benchmarking framework.</p>
<ul>
<li>Estimated capacity: <picture><source srcset="form_4_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ 2^{51} $" src="form_4.png"/></picture> bytes</li>
<li>Register pressure: 4</li>
<li>State size: 128 bits</li>
</ul>
<p>This random generator is a drop-in replacement for the generators supplied by <code>&lt;random&gt;</code>. It is not cryptographically secure. It's intended purpose is to be very fast so that benchmarks that make use of randomness are not distorted too much by the random generator.</p>
<p><a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> also provides a few non-standard helpers, optimized for speed. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4b113050f04adf292a2f32a5463b9105" name="a4b113050f04adf292a2f32a5463b9105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b113050f04adf292a2f32a5463b9105">&#9670;&#160;</a></span>Rng() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ankerl::nanobench::Rng::Rng </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>As a safety precaution, we don't allow copying. Copying a PRNG would mean you would have two random generators that produce the same sequence, which is generally not what one wants. Instead create a new rng with the default constructor <a class="el" href="classankerl_1_1nanobench_1_1Rng.html#a765caca3a2c4896c54aa0419f4680b39" title="Creates a new Random generator with random seed.">Rng()</a>, which is automatically seeded from <code>std::random_device</code>. If you really need a copy, use <code>copy()</code>. </p>

</div>
</div>
<a id="a765caca3a2c4896c54aa0419f4680b39" name="a765caca3a2c4896c54aa0419f4680b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a765caca3a2c4896c54aa0419f4680b39">&#9670;&#160;</a></span>Rng() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ankerl::nanobench::Rng::Rng </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new Random generator with random seed. </p>
<p>Instead of a default seed (as the random generators from the STD), this properly seeds the random generator from <code>std::random_device</code>. It guarantees correct seeding. <a class="el" href="classNote.html" title="Модель даних для однієї нотатки.">Note</a> that seeding can be relatively slow, depending on the source of randomness used. So it is best to create a <a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> once and use it for all your randomness purposes. </p>

</div>
</div>
<a id="a2f806b6c152353221767435ae74fc282" name="a2f806b6c152353221767435ae74fc282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f806b6c152353221767435ae74fc282">&#9670;&#160;</a></span>Rng() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ankerl::nanobench::Rng::Rng </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> that is seeded with a specific seed. Each <a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> created from the same seed will produce the same randomness sequence. This can be useful for deterministic behavior.</p>
<pre class="fragment">embed:rst
.. note::

   The random algorithm might change between nanobench releases. Whenever a faster and/or better random
   generator becomes available, I will switch the implementation.
</pre><p>As per the Romu paper, this seeds the <a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> with splitMix64 algorithm and performs 10 initial rounds for further mixing up of the internal state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seed</td><td>The 64bit seed. All values are allowed, even 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a08c9c7bd41ec8944f542e512ea7d6038" name="a08c9c7bd41ec8944f542e512ea7d6038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c9c7bd41ec8944f542e512ea7d6038">&#9670;&#160;</a></span>ANKERL_NANOBENCH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ankerl::nanobench::Rng::ANKERL_NANOBENCH </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWriter.html">NODISCARD</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a copy of the <a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a>, thus the copy provides exactly the same random sequence as the original. </p>

</div>
</div>
<a id="afb3219bbffe1d0f487e69a0bc9c0f00e" name="afb3219bbffe1d0f487e69a0bc9c0f00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb3219bbffe1d0f487e69a0bc9c0f00e">&#9670;&#160;</a></span>bounded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ankerl::nanobench::Rng::bounded </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates a random number between 0 and range (excluding range).</p>
<p>The algorithm only produces 32bit numbers, and is slightly biased. The effect is quite small unless your range is close to the maximum value of an integer. It is possible to correct the bias with rejection sampling (see <a href="https://lemire.me/blog/2016/06/30/fast-random-shuffling/">here</a>, but this is most likely irrelevant in practices for the purposes of this <a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a>.</p>
<p>See Daniel Lemire's blog post <a href="https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/">A fast alternative to the modulo reduction</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>Upper exclusive range. <a class="el" href="classWriter.html#af4f54830d6927d9daf5bd53bfd134dd3" title="Constructor.">E.g</a> a value of 3 will generate random numbers 0, 1, 2. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint32_t Generated random values in range [0, range(. </dd></dl>

</div>
</div>
<a id="a2c7b5e0d8b201e7367dc44b40910b81c" name="a2c7b5e0d8b201e7367dc44b40910b81c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7b5e0d8b201e7367dc44b40910b81c">&#9670;&#160;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t ankerl::nanobench::Rng::operator() </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produces a 64bit random value. This should be very fast, thus it is marked as inline. In my benchmark, this is ~46 times faster than <code>std::default_random_engine</code> for producing 64bit random values. It seems that the fastest std contender is <code>std::mt19937_64</code>. Still, this RNG is 2-3 times as fast. </p>
<dl class="section return"><dt>Returns</dt><dd>uint64_t The next 64 bit random value. </dd></dl>

</div>
</div>
<a id="aa1ced30ccef127468deea63617c9d4fd" name="aa1ced30ccef127468deea63617c9d4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ced30ccef127468deea63617c9d4fd">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> &amp; ankerl::nanobench::Rng::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classankerl_1_1nanobench_1_1Rng.html#a4b113050f04adf292a2f32a5463b9105">Rng(Rng const&amp;)</a>, we don't allow assignment. If you need a new <a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a> create one with the default constructor <a class="el" href="classankerl_1_1nanobench_1_1Rng.html#a765caca3a2c4896c54aa0419f4680b39" title="Creates a new Random generator with random seed.">Rng()</a>. </p>

</div>
</div>
<a id="a5314a16ff500c254f8431cc3a03578f9" name="a5314a16ff500c254f8431cc3a03578f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5314a16ff500c254f8431cc3a03578f9">&#9670;&#160;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="classWriter.html">typename</a> <a class="el" href="classWriter.html">Container</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWriter.html">void</a> ankerl::nanobench::Rng::shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classWriter.html">Container</a> &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shuffles all entries in the given container. Although this has a slight bias due to the implementation of <a class="el" href="classankerl_1_1nanobench_1_1Rng.html#afb3219bbffe1d0f487e69a0bc9c0f00e">bounded()</a>, this is preferable to <code>std::shuffle</code> because it is over 5 times faster. See Daniel Lemire's blog post <a href="https://lemire.me/blog/2016/06/30/fast-random-shuffling/">Fast random shuffling</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The whole container will be shuffled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac70a7784c044c9870682eb22094049fb" name="ac70a7784c044c9870682eb22094049fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70a7784c044c9870682eb22094049fb">&#9670;&#160;</a></span>uniform01()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classWriter.html">double</a> ankerl::nanobench::Rng::uniform01 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provides a random uniform double value between 0 and 1. This uses the method described in <a href="http://prng.di.unimi.it/">Generating uniform doubles in the unit interval</a>, and is extremely fast.</p>
<dl class="section return"><dt>Returns</dt><dd>double Uniformly distributed double value in range [0,1(, excluding 1. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libs/<a class="el" href="nanobench_8h_source.html">nanobench.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>ankerl</b></li><li class="navelem"><b>nanobench</b></li><li class="navelem"><a class="el" href="classankerl_1_1nanobench_1_1Rng.html">Rng</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
